<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>输入url到页面的加载完成发生了什么？</title>
      <link href="/2019/08/01/url/"/>
      <url>/2019/08/01/url/</url>
      
        <content type="html"><![CDATA[<p>从浏览器中输入URL到页面的加载发生了什么？</p><a id="more"></a><p>一、过程<br>    1、DNS解析：<br>    2、TCP的三次握手<br>    3、发送HTTP请求<br>    4、服务器处理请求并返回报文<br>    5、浏览器解析渲染页面<br>    6、连接结束</p>]]></content>
      
      
      
        <tags>
            
            <tag> url、tcp、http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年8月1日以后的计划</title>
      <link href="/2019/08/01/plan/"/>
      <url>/2019/08/01/plan/</url>
      
        <content type="html"><![CDATA[<p>给自己制订一个计划，希望2019年结束后，完成下面的目标：</p><a id="more"></a><h5 id="一、熟悉微信小程序开发"><a href="#一、熟悉微信小程序开发" class="headerlink" title="一、熟悉微信小程序开发"></a>一、熟悉微信小程序开发</h5><h5 id="二、看完ES6标准后半部分"><a href="#二、看完ES6标准后半部分" class="headerlink" title="二、看完ES6标准后半部分"></a>二、看完ES6标准后半部分</h5><h5 id="三、Vue3-0"><a href="#三、Vue3-0" class="headerlink" title="三、Vue3.0"></a>三、Vue3.0</h5><h5 id="四、继续Blog的更新"><a href="#四、继续Blog的更新" class="headerlink" title="四、继续Blog的更新"></a>四、继续Blog的更新</h5><h5 id="五、带爸妈去旅游一趟"><a href="#五、带爸妈去旅游一趟" class="headerlink" title="五、带爸妈去旅游一趟"></a>五、带爸妈去旅游一趟</h5>]]></content>
      
      
      
        <tags>
            
            <tag> plan、2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖（debounce）和节流（throttle）</title>
      <link href="/2019/07/09/debounce-throttling/"/>
      <url>/2019/07/09/debounce-throttling/</url>
      
        <content type="html"><![CDATA[<p>防抖（<code>debounce</code>）：任务频繁触发情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。</p><a id="more"></a><p>节流（<code>throttle</code>）：指定时间间隔内只会执行一次任务。<br>&emsp;防抖与节流的原理：使用setTimeout来存放将要执行的函数。其中函数节流就是利用标记符来控制本次执行完毕。函数防抖就是利用clearTimeout来清楚执行的函数。目的为了节约计算机资源，从而达到一个更好的运行效果。</p><h3 id="一、防抖"><a href="#一、防抖" class="headerlink" title="一、防抖"></a>一、防抖</h3><p>&emsp;用户在输入框内容校验等操作时，如果事件处理函数的调用频率无限制，会加重浏览器的负担，导致用户体验会很不好，防抖和节流的方式减少调用频率，同时又不影响实际效果。</p><p>下面是一个防抖的小案例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">"debounce"</span>&gt;点我防抖&lt;/button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.onload = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            //获取按钮并绑定事件</span><br><span class="line">            var myDebounce = document.getElementById(<span class="string">"debounce"</span>);</span><br><span class="line">            myDebounce.addEventListener(<span class="string">"click"</span>,debounce(sayDebounce));</span><br><span class="line">        &#125;;</span><br><span class="line">        //防抖功能函数，接受传参</span><br><span class="line">        <span class="keyword">function</span> debounce(fn)&#123;</span><br><span class="line">            //创建一个标记用来存放定时器的返回值</span><br><span class="line">            <span class="built_in">let</span> timeout = null;</span><br><span class="line">            <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                //每次当用户点击、输入的时候，把前一个定时器消除</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                //创建一个新的setTimeout，这样能保证点击按钮后的间隔内，</span><br><span class="line">                //如果用户还点击的话，就不会执行fn函数</span><br><span class="line">                timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                    fn.call(this,arguments);</span><br><span class="line">                &#125;,1000);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        //防抖事件的处理</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">sayDebounce</span></span>()&#123;</span><br><span class="line">            // ...有些需要防抖的工作，在这里进行</span><br><span class="line">            console.log(<span class="string">"防抖成功~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在触发点击事件后，如果用户再次点击了，我们会清空之前的定时器，重新生成一个定时器。意思就是：这件事儿需要等待，如果你反复催促，就重新计时。<br>&emsp;总结一下就是：第一次触发事件，一段时间内没有再次触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，再一次触发了事件，就会重新开始延时。</p><h3 id="二、节流"><a href="#二、节流" class="headerlink" title="二、节流"></a>二、节流</h3><p>&emsp;节流：指定时间间隔内只会执行一次任务。<br>节流的应用：<br>    1、懒加载监听滚动条的位置，使用节流按照一定的频率进行获取。<br>    2、点击提交按钮，只允许一定时间内点击一次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">"throttle"</span>&gt;点我防抖&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        //获取按钮并绑定事件</span><br><span class="line">        var myThrottle = document.getElementById(<span class="string">"throttle"</span>);</span><br><span class="line">        myThrottle.addEventListener(<span class="string">"click"</span>,throttle(sayThrottle));</span><br><span class="line">    &#125;;</span><br><span class="line">    //节流函数</span><br><span class="line">    <span class="keyword">function</span> throttle(fn)&#123;</span><br><span class="line">        //通过闭包保存一个标记</span><br><span class="line">        <span class="built_in">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            //在函数开头判断标志是否为<span class="literal">true</span>，不为<span class="literal">true</span>则中断函数</span><br><span class="line">            <span class="keyword">if</span>(!canRun)&#123;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //将canRun设置为<span class="literal">false</span>，防止执行之前再被执行</span><br><span class="line">            canRun  = <span class="literal">false</span>;</span><br><span class="line">            //定时器</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                fn.call(this,arguments);</span><br><span class="line">                //执行完事件(例如调用完接口)之后，重新将这个标志设置为<span class="literal">true</span></span><br><span class="line">                canRun  = <span class="literal">true</span>;</span><br><span class="line">            &#125;,1000);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    //需要节流的事件</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">sayThrottle</span></span>()&#123;</span><br><span class="line">        // ...有些需要防抖的工作，在这里进行</span><br><span class="line">        console.log(<span class="string">"节流成功~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> debounce、throttle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几个常用的Linux命令</title>
      <link href="/2019/07/09/command/"/>
      <url>/2019/07/09/command/</url>
      
        <content type="html"><![CDATA[<p>在开发过程中，一些常用的Linux命令：</p><a id="more"></a><h3 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h3><p>1、<code>vim test.html</code>   创建新的文件<br>  &emsp;  vim + 文件名.后缀<br>2、<code>ls</code>     查看当前文件夹下的文件<br>&emsp;   <code>ls -a</code>  列出所有文件，包括隐藏文件<br>&emsp;   <code>ls -1</code>  每行列出一个文件，以单列形式列出<br>3、<code>cat test.html</code>  将该文件内容打印显示出来<br>&emsp;   <code>cat test1.html</code><br>&emsp;   <code>cat test2.html</code><br>&emsp;   <code>cat test1.html     test2.html&gt;test3.html</code><br>&emsp;   <code>cat test3.html</code>    将多个文件合并到目标文件中。</p><p>&emsp;   <code>cat test1.html</code><br>&emsp;   <code>cat test2.html</code><br>&emsp;   <code>cat test1.html test2.html&gt;&gt;test4.html</code>   将几个文件附加到目录文件中<br>4、<code>mv</code>   移动或重命名文件和目录<br>&emsp;   <code>mv file1.txt file2.txt</code>   将file1文件命名为file2<br>&emsp;   用法：<br>&emsp;   <code>cat 1.txt</code><br>&emsp;   <code>mv 1.txt 2.txt</code><br>&emsp;   <code>mv file1.txt file2</code>  将file1文本移动到file2目录<br>5、<code>touch  file</code>   命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的空白文件。<br>&emsp;   <code>touch newfile</code><br>6、<code>mkdir file</code>    创建文件夹<br>7、<code>cd ../</code>   返回当前文件夹的上一层<br>&emsp;   <code>cd /</code>     返回到根目录下<br>8、<code>rm -rf folder</code>   删除文件夹</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解原型链中的prototype和__proto__？</title>
      <link href="/2019/07/07/prototype/"/>
      <url>/2019/07/07/prototype/</url>
      
        <content type="html"><![CDATA[<p>JavaScript是动态的，本身不提供一个class实现。在ES2015/ES6中引入了class关键字，但那只是语法糖，JavaScript仍然是基于原型的。</p><a id="more"></a><h3 id="一、什么是原型链？"><a href="#一、什么是原型链？" class="headerlink" title="一、什么是原型链？"></a>一、什么是原型链？</h3><p>&emsp;&emsp;谈到继承时，JavaScript只有一种结构：<strong>对象</strong>。 MDN文档上是这样说的：每个实例对象（object）都有一个私有属性（称之为<code>__proto__</code>）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象（<code>__proto__</code>）,层层向上直到一个对象的原型对象为null。根据定义，null没有原型，并作为这个原型链中的最后一个环节。</p><h3 id="二、换种方式理解原型链？"><a href="#二、换种方式理解原型链？" class="headerlink" title="二、换种方式理解原型链？"></a>二、换种方式理解原型链？</h3><p>&emsp;&emsp;之前在慕课网上，听过一个讲师举了一个很有趣的例子来介绍什么是prototype（当时偷偷的用手机截了图^o^）:<br>&emsp;&emsp;简单粗暴一点，我们把prototype理解成一个“备胎”,手艺还是祖传的。有一个姑娘不会修电脑，自己也不想学，就去找prototype说你学学吧，学好了帮我把修电脑这活儿做好,<br>prototype学会了修电脑之后,这个姑娘电脑有问题就会去找prototype,其他的姑娘再想修电脑时候，prototype这修电脑的技术也能直接拿出来用。<br>后来，又有姑娘请prototype帮忙诊个脉,prototype没有地方学,就往祖上一辈辈的问去，后来了解到他爷爷会诊脉，后来再有人找他诊脉，prototype就把病人带着找它爷爷。<br>再后来，又有一个姑娘让prototype给她造个机器人，prototype问遍了祖上，没人会这门技术，只能告诉这姑娘null了。</p><h3 id="三、为什么需要原型和原型链？"><a href="#三、为什么需要原型和原型链？" class="headerlink" title="三、为什么需要原型和原型链？"></a>三、为什么需要原型和原型链？</h3><p>&emsp;&emsp;看一个小例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age  = age;</span><br><span class="line">    this.eat  = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(age + <span class="string">"岁的"</span> + name + <span class="string">"在吃饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> p1 = new Person(<span class="string">"YQ"</span>,27);</span><br><span class="line"><span class="built_in">let</span> p2 = new Person(<span class="string">"YQ"</span>,27);</span><br><span class="line">console.log(p1.eat === p2.eat);  //<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们发现上面的例子,对于同一个函数,我们可以通过new生成出来的实例,p1和p2的eat是不同的。我们想个办法，建立一个类似于共享库的对象，这样就可以在需要的时候，调用一个类似共享库的对象，让实例能够沿着某个“线索”去找到自己的归处。<br>这个“线索”就是我们的原型链 prototype。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">//通过构造函数的Person的prototype属性找到Person的原型对象</span><br><span class="line">Person.prototype.eat = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"吃饭"</span>)；</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> p1 = new Person(<span class="string">"YQ"</span>,27);</span><br><span class="line"><span class="built_in">let</span> p2 = new Person(<span class="string">"于齐"</span>,27)</span><br><span class="line"></span><br><span class="line">console.log(p1.eat === p2.eat);//<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&emsp;通过分享的形式，这两个实例对象指向相同的位置了，也就是我们想要创建的共享库的对象。</p><h3 id="四、prototype是什么玩意儿呢？"><a href="#四、prototype是什么玩意儿呢？" class="headerlink" title="四、prototype是什么玩意儿呢？"></a>四、prototype是什么玩意儿呢？</h3><p>知乎上有一篇文章（<a href="https://zhuanlan.zhihu.com/p/22989691）" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22989691）</a> 写的很好，总结一下就是：<br>1、JavaScript本源是空的，即：null,这个就是JavaScript的“始祖”；</p><p>2、null通过<code>__proto__</code>产生了NO1,即：<code>NO1.__proto__ == null</code>;  </p><p>3、NO1根据自己的原型prototype创建了对象Object，即：<code>Object.prototype == NO1</code>;</p><p>4、<code>NO1.__proto__ == null</code>,我们把prototype叫做原型，好比Object的原型是神，同时<strong>proto</strong>叫做原型链，有了这个<strong>proto</strong>，Object、NO1、JS之间才有联系，此时，<code>Object.prototype.__proto__ == null</code>，</p><p>5、有几条公式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.__proto__ === Function.prototype;</span><br><span class="line">Function.prototype.__proto__ === Object.prototype;</span><br><span class="line">Object.prototype.__proto__ === null;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 原型链、prototype、__proto__ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class语法</title>
      <link href="/2019/07/03/ES6/"/>
      <url>/2019/07/03/ES6/</url>
      
        <content type="html"><![CDATA[<p>一、Class语法：<br>    Class在语法上更加贴合面向对象的写法；Class实现继承更易读、易理解；本质是语法糖，使用了prototype。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ class Mathhandle&#123;</span><br><span class="line">    constructor(x,y)&#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">add</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> this.x + this.y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  const mm = new Mathhandle(1,2);</span><br><span class="line">  console.log(mm.add());</span><br><span class="line"></span><br><span class="line">  typeof Mathhandle    //<span class="keyword">function</span></span><br><span class="line">  console.log(Mathhandle === Mathhandle.prototype.constructor); // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>二、Class继承</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">eat</span></span>()&#123;</span><br><span class="line">        console.log(this.name + <span class="string">'eat'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extend Animal&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        super(name)</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">say</span></span>()&#123;</span><br><span class="line">        console.log(`<span class="variable">$&#123;this.name&#125;</span> eat`)</span><br><span class="line">    &#125;</span><br><span class="line">    const dog = new Dog(<span class="string">'hashiqi'</span>);</span><br><span class="line">    dog.say();</span><br><span class="line">    dog.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ES6、JavaScript、Class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的书单--持续更新。。。</title>
      <link href="/2019/07/01/book/"/>
      <url>/2019/07/01/book/</url>
      
        <content type="html"><![CDATA[<p>如果累了，就停下来看看书，冷静一下。</p><a id="more"></a><p>2019年下半年准备看的书单</p><h3 id="一、书单详情"><a href="#一、书单详情" class="headerlink" title="一、书单详情"></a>一、书单详情</h3><p>1、《不要让未来的你讨厌现在的自己》  作者：特立独行的猫<br>2、《ES6标准入门（第二版）》        作者：阮一峰<br>3、<br>。。<br>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise</title>
      <link href="/2019/06/19/promise/"/>
      <url>/2019/06/19/promise/</url>
      
        <content type="html"><![CDATA[<p>Promise是异步编程的一种解决方案，简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p><a id="more"></a><!-- <Excerpt in index | 首页摘要>  --><p>语法上讲，Promise是一个对象，从它可以获取异步操作的消息。<br>Promise的两个特点：<br>    （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。<br>    （2）一旦状态改变，就不会改变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。<br>一、Promise基本用法：<br>    1、Promise实例：<br>        Promise构造函数接受一个函数作为参数，该函数的两个函数分别是resolve和reject</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ const promise = new Promise(<span class="keyword">function</span>(resolve,reject)&#123;</span><br><span class="line">      // ... some code </span><br><span class="line">      <span class="keyword">if</span>(/*异步操作成功*/)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>Promise实例生成后，可以用 then方法分别指定resolved状态和rejected状态的回调函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ promise.then(<span class="keyword">function</span>(value)&#123;</span><br><span class="line">    //success</span><br><span class="line">    &#125;,<span class="keyword">function</span>(error)&#123;</span><br><span class="line">    //failure</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>二、使用Promise分别获取图片的宽高<br>  new Promise实例，而且要return，new Promise时要传入函数，函数有resolve reject两个参数，成功时执行resolve（）、失败时执行reject（）、<br>then监听结果  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">function</span> <span class="function"><span class="title">loadImg</span></span>()&#123;</span><br><span class="line">    const promise = new Promise(<span class="keyword">function</span>(resolve,reject)&#123;</span><br><span class="line">      var img = document.createElement(<span class="string">'img'</span>)</span><br><span class="line">      img.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        resolve(img)</span><br><span class="line">      &#125;</span><br><span class="line">      img.<span class="function"><span class="title">onerror</span></span>()&#123;</span><br><span class="line">        reject()</span><br><span class="line">      &#125;</span><br><span class="line">      img.src = src</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="built_in">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line">var src = <span class="string">'https://www.imooc.com/static/img/index/logo.png'</span></span><br><span class="line">var result = loadImg(src)</span><br><span class="line">//获取图片的宽度</span><br><span class="line">result.then(<span class="keyword">function</span>(img)&#123;</span><br><span class="line">  console.log(img.width)</span><br><span class="line">&#125;,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  console.log(<span class="string">'failed'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">//获取图片的高度</span><br><span class="line">result.then(<span class="keyword">function</span>(img)&#123;</span><br><span class="line">  console.log(img.height)</span><br><span class="line">&#125;,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  console.log(<span class="string">'failed'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Javascript、Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Github Pages + Yelee主题 + 阿里云域名搭建个人博客</title>
      <link href="/2019/06/19/hello-world/"/>
      <url>/2019/06/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hexo 常用命令</p><a id="more"></a><h3 id="一、Create-a-new-post-–创建新文章"><a href="#一、Create-a-new-post-–创建新文章" class="headerlink" title="一、Create a new post –创建新文章"></a>一、Create a new post –创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><h3 id="二、Create-a-new-page-–创建新页面"><a href="#二、Create-a-new-page-–创建新页面" class="headerlink" title="二、Create a new page –创建新页面"></a>二、Create a new page –创建新页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page <span class="string">"pageName"</span></span><br></pre></td></tr></table></figure><h3 id="三、Run-server-–启动服务器"><a href="#三、Run-server-–启动服务器" class="headerlink" title="三、Run server –启动服务器"></a>三、Run server –启动服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server  简写：hexo s</span><br></pre></td></tr></table></figure><h3 id="四、Generate-static-files-–生成静态文件"><a href="#四、Generate-static-files-–生成静态文件" class="headerlink" title="四、Generate static files –生成静态文件"></a>四、Generate static files –生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate --生成静态文件   简写： hexo g</span><br></pre></td></tr></table></figure><h3 id="五、Deploy-to-remote-sites-–部署到远程站点"><a href="#五、Deploy-to-remote-sites-–部署到远程站点" class="headerlink" title="五、Deploy to remote sites –部署到远程站点"></a>五、Deploy to remote sites –部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy --部署文章   简写：hexo d</span><br></pre></td></tr></table></figure><h3 id="六、hexo常用命令"><a href="#六、hexo常用命令" class="headerlink" title="六、hexo常用命令"></a>六、hexo常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page <span class="string">"pageName"</span>  <span class="comment">#新建页面</span></span><br><span class="line">$ hexo new <span class="string">"postName"</span>   <span class="comment">#新建页面</span></span><br><span class="line">$ hexo generate  <span class="comment">#生成静态页面至public目录  简写：hexo g</span></span><br><span class="line">$ hexo server  <span class="comment">#开始预览访问端口（默认端口4000，Ctrl + C终止server） 简写：hexo s</span></span><br><span class="line">$ hexo deploy  <span class="comment">#部署到GitHub 简写：hexo d</span></span><br></pre></td></tr></table></figure><h3 id="七、Github根目录下创建CNAME文件（无后缀）"><a href="#七、Github根目录下创建CNAME文件（无后缀）" class="headerlink" title="七、Github根目录下创建CNAME文件（无后缀）"></a>七、Github根目录下创建CNAME文件（无后缀）</h3><p>在CNAME文件里面填写我的域名（加不加www看自己的喜好），下面是我的Github根目录下创建的CANAME文件。<br>阿里云域名解析过程不详细赘述……</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xiaoyucode.top</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
