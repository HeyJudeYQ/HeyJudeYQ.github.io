{"meta":{"title":"小鱼儿","subtitle":null,"description":"Javascript Vue CSS HTML","author":"小鱼儿","url":"issummer.cn","root":"/"},"pages":[{"title":"404","text":"title: 404 Not Found：该页无法显示toc: falsecomments: falsepermalink: /404","path":"404/index.html","date":"06-29","excerpt":""},{"title":"关于我","text":"一个比较菜的web前端开发工程师！","path":"about/index.html","date":"06-29","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"05-12","excerpt":""},{"title":"tags","text":"–","path":"tags/index.html","date":"06-29","excerpt":""}],"posts":[{"title":"微信公众号网页禁止当前页面的返回-popstate","text":"在移动端禁止微信浏览器键返回键。 一、HTML5—popstate事件MDN上是这样介绍popstate的： 当活动历史记录条目更改时，将触发popstate事件。如果被激活的历史记录条目是通过对history.pushState（）的调用创建的，或者受到对history.replaceState（）的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。 需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()或者history.forward()方法） 不同的浏览器在加载页面时处理popstate事件的形式存在差异。页面加载时Chrome和Safari通常会触发(emit )popstate事件，但Firefox则不会。 我负责的一个项目中，在微信公众号网页的某一个页面需要禁止使用微信浏览器的返回键。 解决方案：12345678910111213在禁止返回的组件的methods中写一个方法forbidBackforbidBack()&#123; window.history.pushState(&quot;forward&quot;,null,&quot;#&quot;); window.history.forward(1);&#125;监听返回键，禁止返回之前的路由if(window.history &amp;&amp; window.history.pushState)&#123; window.addEventListener(&quot;popstate&quot;,this.forbidBack,false); this.forbidBack();&#125;离开页面需要销毁监听 window.removeEventListener(&quot;popstate&quot;,this.forbidBack,fasle);","path":"2020/06/09/popstate/","date":"06-09","excerpt":"在移动端禁止微信浏览器键返回键。","tags":[]},{"title":"移动设备rem和lib-flexible","text":"移动端适配的目的：不同尺寸的移动设备，显示同样的 web 界面，相对性达到合理的展示。 一、安装 lib-flexible 插件1npm install lib-flexible --save 安装完成后需要在vue项目中的main.js中引入。12// main.jsimport &quot;lib-flexible/flexible.js&quot; 二、viewport 设置设置viewport的目的就是为了无法通过手指放大和缩小页面，使的页面比例始终为1：11&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=0,minimum-scale=1.0,maximum=scale=1.0&quot;&gt;","path":"2020/06/05/rem/","date":"06-05","excerpt":"移动端适配的目的：不同尺寸的移动设备，显示同样的 web 界面，相对性达到合理的展示。","tags":[]},{"title":"vue移动端项目300ms延迟在IOS11系统中的bug","text":"在移动端点击一个元素触发事件的顺序为：touchstart –&gt; touchmove –&gt; touchend –&gt; click 一、解决方案1、禁用缩放 更改默认视口宽度 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1&quot;&gt; 2、fastclick解决300ms延迟问题 首先，需要安装fastclick插件 1npm install fastclick 3、在main.js文件中引入fastclick，绑定到body上 12import FastClick from &quot;fastclick&quot;FastClick.attach(document.body); 这就是常用来解决移动端300ms延迟的方法。 二、iOS11系统中出现的bug在iOS11系统下，点击input输入框的时候会出现不灵敏的现象。 解决方案:1234567891011121314FastClick.prototype.focus = function (targetElement) &#123; var length; var deviceIsWindowsPhone = navigator.userAgent.indexOf(&quot;Windows Phone&quot;) &gt;= 0; var deviceIsIos = /iP(ad|hone|od)/.test(navigator.userAgent) &amp;&amp; !deviceIsWindowsPhone; //兼容处理:在iOS7中，有一些元素（如date、datetime、month等）在setSelectionRange会出现TypeError //这是因为这些元素并没有selectionStart和selectionEnd的整型数字属性，所以一旦引用就会报错，因此排除这些属性才使用setSelectionRange方法 if (deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(&apos;date&apos;) !== 0 &amp;&amp; targetElement.type !== &apos;time&apos; &amp;&amp; targetElement.type !== &apos;month&apos;) &#123; length = targetElement.value.length; // 修复bug ios 11.3不弹出键盘，这里加上聚焦代码，让其强制聚焦弹出键盘 targetElement.setSelectionRange(length, length); &#125; else &#123; targetElement.focus(); &#125;&#125; 注意： setSelectionRange是HTMLInputElement的一个方法,用来设定input textare的当前文本的起始位置和结束位置。MDN文档） 对setSelectionRange方法只能用于类型为文本、搜索、连接、电话号码、密码的输入，以及在Chrome33开始访问其余类型的属性和方法抛出异常。 输入类型为数字时会抛出：“不能从’HTMLInputElement’中读取’selectionStart’属性：输入元素的类型(‘number’)不支持选择（Failed to read the ‘selectionStart’ property from ‘HTMLInputElement’: The input element’s type (‘number’) does not support selection）”。","path":"2020/06/03/fastclick/","date":"06-03","excerpt":"在移动端点击一个元素触发事件的顺序为：touchstart –&gt; touchmove –&gt; touchend –&gt; click","tags":[]},{"title":"常用的校验-validate","text":"经常使用的校验正则 一、判断是否为外链123export function isExternal(path)&#123; return /^(https?:|mailto:|tel:)/.test(path);&#125; 二、密码是否小于6位123export function isPassword(str)&#123; return str.length &gt;= 6;&#125; 三、判断是否为数字1234export function isNumber(value)&#123; const reg = /^[0-9]*$/; return reg.test(value);&#125; 四、判断是否是名称1234export function isName(value)&#123; const reg = /^[\\u4e00-\\u9fa5a-zA-Z0-9]+$/; return reg.test(value);&#125; 五、判断是否为IP1234export function isIP(ip) &#123; const reg = /^(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])$/; return reg.test(ip);&#125; 六、判断是否为传统网站1234export function isUrl(url) &#123; const reg = /^(https?|ftp):\\/\\/([a-zA-Z0-9.-]+(:[a-zA-Z0-9.&amp;%$-]+)*@)*((25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;|[1-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;|[1-9]?[0-9]))&#123;3&#125;|([a-zA-Z0-9-]+\\.)*[a-zA-Z0-9-]+\\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]&#123;2&#125;))(:[0-9]+)*(\\/($|[a-zA-Z0-9.,?&apos;\\\\+&amp;%$#=~_-]+))*$/; return reg.test(url);&#125; 七、判断是否为小写字母1234export function isLowerCase(str) &#123; const reg = /^[a-z]+$/; return reg.test(str);&#125; 八、判断是否为大写字母1234export function isUpperCase(str) &#123; const reg = /^[A-Z]+$/; return reg.test(str);&#125; 九、判断是否是大写字母开头1234export function isAlphabets(str) &#123; const reg = /^[A-Za-z]+$/; return reg.test(str);&#125; 十、判断是否是字符串123export function isString(str) &#123; return typeof str === &quot;string&quot; || str instanceof String;&#125; 十一、判断是否为数组123456export function isArray(arg) &#123; if (typeof Array.isArray === &quot;undefined&quot;) &#123; return Object.prototype.toString.call(arg) === &quot;[object Array]&quot;; &#125; return Array.isArray(arg);&#125; 十二、判断是否是端口号1234export function isPort(str) &#123; const reg = /^([0-9]|[1-9]\\d|[1-9]\\d&#123;2&#125;|[1-9]\\d&#123;3&#125;|[1-5]\\d&#123;4&#125;|6[0-4]\\d&#123;3&#125;|65[0-4]\\d&#123;2&#125;|655[0-2]\\d|6553[0-5])$/; return reg.test(str);&#125; 十三、判断是否是手机号码1234export function isPhone(str) &#123; const reg = /^1\\d&#123;10&#125;$/; return reg.test(str);&#125; 十四、判断是否是身份证号（二代）1234export function isIdCard(str) &#123; const reg = /^[1-9]\\d&#123;5&#125;(18|19|([23]\\d))\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$/; return reg.test(str);&#125; 十五、判断是否是邮箱1234export function isEmail(str) &#123; const reg = /^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/; return reg.test(str);&#125; 十六、判断是否为中文1234export function isChina(str) &#123; const reg = /^[\\u4E00-\\u9FA5]&#123;2,4&#125;$/; return reg.test(str);&#125; 十七、判断是否为空123456789export function isBlank(str) &#123; return ( str == null || false || str === &quot;&quot; || str.trim() === &quot;&quot; || str.toLocaleLowerCase().trim() === &quot;null&quot; );&#125; 十八、判断是否为固话1234export function isTel(str) &#123; const reg = /^(400|800)([0-9\\\\-]&#123;7,10&#125;)|(([0-9]&#123;4&#125;|[0-9]&#123;3&#125;)(-| )?)?([0-9]&#123;7,8&#125;)((-| |转)*([0-9]&#123;1,4&#125;))?$/; return reg.test(str);&#125; 十九、判断是否为数字且最多两位小数1234export function isNum(str) &#123; const reg = /^\\d+(\\.\\d&#123;1,2&#125;)?$/; return reg.test(str);&#125; 二十、判断经度（-180.0 ~ +180.0,必须输入1到5位小数）、维度（整数部分为0~90，必须输入1到5位小数）1234567891011// 经度export function isLongitude(str) &#123; const reg = /^[-|+]?(0?\\d&#123;1,2&#125;\\.\\d&#123;1,5&#125;|1[0-7]?\\d&#123;1&#125;\\.\\d&#123;1,5&#125;|180\\.0&#123;1,5&#125;)$/; return reg.test(str);&#125;// 维度export function isLatitude(str) &#123; const reg = /^[-|+]?([0-8]?\\d&#123;1&#125;\\.\\d&#123;1,5&#125;|90\\.0&#123;1,5&#125;)$/; return reg.test(str);&#125;","path":"2020/05/25/validate/","date":"05-25","excerpt":"经常使用的校验正则","tags":[]},{"title":"nrm切换npm源","text":"因为在使用npm下载插件的过程中速度太慢了（npm源在国外），所以找到一个切换源的方法：nrm。 一、切换成淘宝源1、config命令的使用 1npm config set registry https://registry.npm.taobao.org 2、命令行指定 1npm i node --registry https://registry.npm.taobao.org info underscore 3、编辑~/.npmrc，加入以下内容： 1registry = https://registry.npm.taobao.org 二、nrm的使用nrm是一个可以切换、添加/删除/测试源的工具1、全局安装nrm 1npm install -g nrm // mac如果出现权限问题，加上sudo 2、安装完成，查看所有的可用源 1nrm ls 3、添加源 1nrm add 源的名称 https:// 地址 4、删除原 1nrm del 源的名字 5、切换到某个源 1nrm use 源的名字 6、测试源速度 1nrm test 例如，我需要使用淘宝源，只需nrm use taobao就可以了，cnpm不要使用，容易出现莫名其妙的错误。","path":"2020/05/19/nrm/","date":"05-19","excerpt":"因为在使用npm下载插件的过程中速度太慢了（npm源在国外），所以找到一个切换源的方法：nrm。","tags":[]},{"title":"关于vue-router路由守卫","text":"使用vue-router，我们需要做的是，将组件（components）映射到路由(routes),然后告诉vue-router在哪里渲染他们。 一、路由守卫路由守卫就像其名字一样，vue-router提供导航守卫主要用来通过跳转或取消的方式守卫导航。1、全局前置守卫 1234const router = new VueRouter(&#123;...&#125;)router.beforeEach((to,from,next) =&gt; &#123; // ...&#125;) 当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫resolve完之前一直出入等待中。 参数说明： to: Route 即将要进入的目标路由对象； from: Route 当前导航正要离开的路由； next: Route 一定要调用该方法来resolve这个钩子。 确保要调用next方法，否则钩子就不会被resolved。2、路由独享的守卫在路由配置上直接定义beforeEnter守卫 1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 这些守卫与全局前置守卫的方法参数是一样的 二、解决路由跳转NavigationDuplicated报错的方式vue-router版本3.1之后，$router.push()方法改为了promise，如果没有回调函数，错误信息就会交给全局的路由错误处理，就会报错！解决方法： 1、简单粗暴的方法：将vue-router的版本固定在vue-router 3.0.7一下 2、在router.js中加入下面的代码 12345// 解决跳转出错问题 NavigationDuplicatedconst originalPush = Router.prototype.pushRouter.prototype.push = function push(location) &#123; return originalPush.call(this, location).catch(err =&gt; err)&#125; 3、给每个router.push增加回调函数。1router.push(&apos;/index&apos;).catch(err =&gt; (err)) 第3种解决方法成本较高，我一般使用第二种方法。三、限制通过URL进入一些用户的个人信息的页面例如：逛天猫的时候，你不登录的时候也可以进入商品详情页等页面，但是由于未登录，进入不了我的购物车、个人信息等需要用户token的页面。所以需要判断是否包含登录token。 123456789101112131415161718192021222324// 导航守卫 进入注册页面不需要是否包含tokenrouter.beforeEach(function (to, from, next) &#123; if (to.path === &apos;/register&apos;) &#123; return next(); &#125; next() // 第一种身份的token1 未登录状态，直接跳转到主页，即使输入准确的的URL地址也无法访问。 if (!localStorage.getItem(&apos;token1&apos;)) &#123; if (to.path !== &apos;/&apos;) &#123; return next(&apos;/&apos;); &#125; &#125; if (!localStorage.getItem(&apos;token2&apos;)) &#123; if (to.path !== &apos;/&apos;) &#123; return next(&apos;/&apos;); &#125; &#125; if (!localStorage.getItem(&apos;token3&apos;)) &#123; if (to.path !== &apos;/&apos;) &#123; return next(&apos;/&apos;); &#125; &#125;&#125;)","path":"2020/05/13/vue-router/","date":"05-13","excerpt":"使用vue-router，我们需要做的是，将组件（components）映射到路由(routes),然后告诉vue-router在哪里渲染他们。","tags":[]},{"title":".eslintrc.js 的配置","text":"在项目目录下新建一个.eslintrc.js的文件。 .eslintrc.js 的配置常用配置： 1234567891011121314151617181920module.exports = &#123; root: true, env: &#123; node: true &#125;, &apos;extends&apos;: [ &apos;plugin:vue/essential&apos;, &apos;@vue/standard&apos; ], rules: &#123; &apos;no-console&apos;: process.env.NODE_ENV === &apos;production&apos; ? &apos;error&apos; : &apos;off&apos;, // 生产环境 无console.log &apos;no-debugger&apos;: process.env.NODE_ENV === &apos;production&apos; ? &apos;error&apos; : &apos;off&apos;, // 生产环境 无debugger &apos;indent&apos;: &apos;off&apos;, // 函数定义时括号前面要不要有空格 &apos;space-before-function-paren&apos;: &apos;off&apos; &#125;, parserOptions: &#123; parser: &apos;babel-eslint&apos; &#125;&#125;","path":"2020/05/09/eslint/","date":"05-09","excerpt":"在项目目录下新建一个.eslintrc.js的文件。","tags":[]},{"title":"解决vue项目热更新、启动和打包时间过长的问题","text":"维护公司一个项目的时候，发现在启动、热更新和打包项目的时候，时间长的“感人”。 当你改动项目的一些地方想要立即看到效果的时候，却发现热更新的编译过程却花了你很长时间，“心态崩了。。。”。 解决方法： 1、使用html-webpack-plugin-for-multihtml插件2、在build-webpack.dev.conf.js文件中1234const HtmlWebpackPlugin = require('html-webpack-plugin');// 替换成const HtmlWebpackPlugin = require('html-webpack-plugin-for-multihtml'); 3、multihtmlCache:true 解决多页热部署的关键1234567891011121314151617 for (var pathname in pages) &#123; // 配置生成的html文件，定义路径等 var conf = &#123; filename: pathname + '.html', template: pages[pathname], // 模板路径 inject: true, // js插入位置 multihtmlCache: true, // 解决多页热部署的关键 这里这里这里这里这里很重要！！！ // necessary to consistently work with multiple chunks via CommonsChunkPlugin chunksSortMode: 'dependency' &#125;; if (pathname in devWebpackConfig.entry) &#123; conf.chunks = ['manifest','vendor', pathname]; conf.hash = false; &#125; devWebpackConfig.plugins.push(new HtmlWebpackPlugin(conf));&#125; 这时候再启动项目，热更新、编译和打包的速度会大大提升。","path":"2020/05/08/time/","date":"05-08","excerpt":"维护公司一个项目的时候，发现在启动、热更新和打包项目的时候，时间长的“感人”。","tags":[]},{"title":"下拉框select的option","text":"下拉的选项是从后台获取的数据,如何获取选定项的值? 以选择银行卡为例： 12345678910&lt;select v-model=\"selected\" class=\"selected\"&gt; &lt;option disabled value v-show=\"showTips\"&gt;请选择提现到账的银行卡&lt;/option&gt; &lt;option v-for=\"item in CardList\" :key=\"item.id\" v-bind:value=\"item.id\" &gt; &#123;&#123; item.card_type &#125;&#125; ( &#123;&#123; item.card_number ? item.card_number.replace(/^(\\d&#123;4&#125;)\\d+(\\d&#123;4&#125;)$/,\"$1****$2\"):\"\"&#125;&#125; ) &lt;/option&gt;&lt;/select&gt; 正则表达式是让银行卡号显示为6217 **** 0000的格式。","path":"2020/05/08/select/","date":"05-08","excerpt":"下拉的选项是从后台获取的数据,如何获取选定项的值?","tags":[]},{"title":"vue项目中遇到的问题","text":"使用Vue开发时遇到的问题 一、跨域因为客户端的同源策略，导致了跨域问题。一般解决办法是：在使用vue-cli初始化的项目，在配置文件中添加proxyTable来解决本地开发的跨域问题。 123456789proxyTable:&#123; '/api':&#123; target:'url',// 接口域名 changeOrigin:true, // 是否启用跨域 pathRewrite:&#123; '^/api':' &#125; &#125;&#125; vue-cli3需要创建一个vue.config.js文件，在此文件中添加配置项。 二、项目打包产生很大的.map文件项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。而生成的.map文件就可以像未加密的代码一样，准确的知道是哪里出了问题。生成环境一般不需要此文件，在config/index.js文件中，设置productionSourceMap:false,就可以不生成.map文件了。 三、fastClick的300ms延迟安装fastclick插件在main.js中引入fastClick 12import FastClick from 'fastclick';FastClick.attach(document.body);// 使用fastclick 四、减少首屏加载速度–路由懒加载路由懒加载可以帮我们在进入首屏的时候，不用加载过度的资源，从而减少首屏的加载速度。路由配置一： 非懒加载方法 12345678910import Index from \"@/pages/Index/Index\"export default new Router(&#123; routes:[ &#123; path:'/', name:'Index', component:Index &#125; ]&#125;) 路由懒加载123456789export default new Router(&#123; routes:[ &#123; path:'/', name:'Index', component:resolve =&gt; require(['@/pages/Index/Index'],resolve) &#125; ]&#125;) 五、减少文件体积–开启gzip安装插件compression-webpack-pluginnpm i compression-webpack-plugin在config/index.js中开启gzip 123build:&#123; productionGzip:true&#125; 六、不要在method中使用箭头函数Vue官网上有说明，问什么不应该在method中使用.在methods不应该使用箭头函数来定义method函数，理由是箭头函数绑定了父级作用域上下文，所以this将不会按照我们的期望指向Vue实例注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () =&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。 七、控制天报错sock.js?9be2:1606控制的报错详情是这个样子的： 1sockjs.js?9be2:1606 GET http://192.168.10.14:8081/sockjs-node/info?t=1588898971642 net::ERR_CONNECTION_REFUSED 解决办法： 1、找到/node_modules/sockjs-client/dist/sockjs.js; 2、在1605行，注释掉self.xhr.send(payload);这一行，然后就可以解决了。 八、修饰符的使用例如：我们有一个点击事件，我们只希望这个点击事件只执行一次，这时候我们可以使用.once修饰符 12345&lt;button @click.once=\"Submit\"&gt;提交&lt;/button&gt;Submit:function()&#123; console.log(123); // 多次点击提交 只会在控制台打印一次&#125;","path":"2020/05/07/vue-question/","date":"05-07","excerpt":"使用Vue开发时遇到的问题","tags":[]},{"title":"iTerm2快捷键","text":"工欲善其事必先利其器。如何更加方便的使用iTerm2？ 一、标签快捷键 123456commond + t // 新建标签页commond + w // 关闭标签commond + enter // 切换全屏(第一次切换至全屏，再commond + enter恢复到之前窗口) commond + 左右方向键 // 切换标签commond + + // 窗口和字体变大commond + - // 窗口和字体变小","path":"2020/04/30/iterm2/","date":"04-30","excerpt":"工欲善其事必先利其器。如何更加方便的使用iTerm2？","tags":[]},{"title":"移动端页面自定义input唤起键盘return，换行改为搜索","text":"移动端页面自定义input唤起键盘return，换行键改为搜索。 在html5中，我们可以将input的type修改为search，这样修改之后，我们的安卓手机会变成搜索或者搜索符号、IOS则会变成换行。1、安卓手机 1&lt;input type=\"search\" placeholder=\"请输入你要搜索的内容\" v-model=\"value\"/&gt; 2、苹果IOS手机与安卓手机不同的是，我们需要在外层包裹一个form 123&lt;from action=\"javascript:return true\"&gt; &lt;input type=\"search\" placeholder=\"请输入你要搜索的内容\" v-model=\"value\"&gt;&lt;/form&gt; 3、修改search的默认样式 123456input[type=\"search\"]&#123; -webkit-appearance:none;&#125;input::-webkit-search-cancel-button&#123; display:none; // 关闭按钮&#125;","path":"2020/04/28/search/","date":"04-28","excerpt":"移动端页面自定义input唤起键盘return，换行键改为搜索。","tags":[]},{"title":"使用Vue开发APP手机虚拟返回键点击退出应用解决办法","text":"如何解决安卓手机的点击虚拟返回键退出当前应用 一、问题描述：最近的项目是使用Vue全家桶+HBuilder打包开发一个移动端APP。在测试的时候发现，当安卓手机使用虚拟按钮的时候，点击虚拟按钮的返回键，APP会直接退出。这是因为安卓手机自带back虚拟按键，如果不修改其默认事件，点一下app就退出了，所以需要修改这个按键默认事件事件的代码。 二、解决办法：在index.html中加入一个script，加上如下代码： 1234567891011121314151617181920212223242526272829&lt;script&gt; document.addEventListener('plusready', function () &#123; var first = null; var webview = plus.webview.currentWebview(); plus.key.addEventListener('backbutton', function () &#123; webview.canBack(function (e) &#123; if (e.canBack) &#123; webview.back(); //这里不建议修改自己跳转的路径 &#125; else &#123; //首次按键，提示‘再按一次退出应用’ if (!first) &#123; first = new Date().getTime(); //获取第一次点击的时间戳 plus.nativeUI.toast(\"再按一次退出应用\", &#123; duration: 'short' &#125;); //通过H5+ API 调用Android 上的toast 提示框 setTimeout(function () &#123; first = null; &#125;, 1000); &#125; else &#123; // 获取第二次点击的时间戳, 两次之差 小于 1000ms 说明1s点击了两次, if (new Date().getTime() - first &lt; 1000) &#123; plus.runtime.quit(); //退出应用 &#125; &#125; &#125; &#125;) &#125;);&#125;);&lt;/script&gt;","path":"2020/04/22/Virtualkey/","date":"04-22","excerpt":"如何解决安卓手机的点击虚拟返回键退出当前应用","tags":[]},{"title":"H5扫码功能","text":"H5APP如何实现扫码功能; 扫码功能的实现（一）、使用H5 API barcode实现扫码功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103# 模板 &lt;template&gt; &lt;div&gt; &lt;div class=\"scan\"&gt; &lt;div id=\"bcid\"&gt;&lt;/div&gt; &lt;footer&gt; &lt;button v-if=\"Start\" @click=\"startRecognize\"&gt;扫 码 加 油&lt;/button&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 扫描对象 var scan = null; data()&#123; return &#123; Begin:true &#125; &#125;, methods:&#123; startRecognize()&#123; const that = this; this.Begin = false; if(!window.plus) return; scan = new plus.barcode.Barcode('bcid'); // 开始扫描 scan.start(); // 扫码成功之后的回调函数 type是类型 result 结果 scan.onmarked = function(type,result)&#123; const text = ''; switch(type)&#123; case plus.barcode.QR: type = 'QR'; break; case plus.barcode.EAN13: type = \"EAN13\"; break; case plus.barcode.EAN8: type = \"EAN8\"; break; default: type = \"其它\" + type; break; &#125; result = result.replace(/\\n/g,\"\"); const id = result.match(/\\d+/)[0]; // token存在vuex里较好 // const Token = localStorage.getItem('token'); that.$router.push(&#123; name:'OrderDetail', params: &#123; id:id, token:token &#125; &#125;); scan.close(); &#125; &#125;, // 关闭扫码识别控件 closeScan()&#123; if(!window.plus) return; scan.close(); this.$router.push('./qrcode'); &#125; &#125; &lt;/script&gt; &lt;style lang=\"less\" scoped&gt; .scan &#123; height: 96vh; background-color: #EFEFEF; #bcid &#123; width: 100vw; height: 96vh; text-align: center; color: #fff; &#125; footer &#123; width: 100%; height: 8rem; line-height: 2rem; font-size: 14px; position: absolute; left: 0; bottom: 10rem; z-index: 999; button &#123; width: 8rem; height: 8rem; border: 4px solid #1f4ba5; border-radius: 50%; font-size: 16px; font-family: PingFangSC-Medium; background-color: #fff; &#125; &#125;&#125; &lt;/style&gt;","path":"2019/12/30/Barcode/","date":"12-30","excerpt":"H5APP如何实现扫码功能;","tags":[{"name":"H5、barcode","slug":"H5、barcode","permalink":"issummer.cn/tags/H5、barcode/"}]},{"title":"如何使用QRCode生成二维码？","text":"在Vue项目中，前端生成站点二维码，使用APP扫码功能达到扫码加油的目的。 一、如何在Vue在使用QRCode生成二维码？（一）、下载插件qrcode插件1npm install qrcode --save （二）、在main.js中引用12import QRCode from 'qrcode'Vue.use(QRCode) (三)、组件中引入QRCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 # 模板 &lt;template&gt; &lt;div&gt; &lt;div id=\"qrcode\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import QRCode from 'qrcode'; mounted()&#123; this.CreateQrcode(); &#125;, method:&#123; setTimeout(() =&gt; &#123; // 获取DOM节点 let dom = document.getElementById('qrcode); // 路由传参 父组件传给子组件的站点id const res = this.$route.params; console.log(res); const id = res.id; // 二维码包含的URL 需要将URL和id做一下字符串的拼接 let url = 'http://*********'; let URL = url.concat(lbsid); let qrCode = new QRCode(dom,&#123; width:260, // 图像宽度 height:260, // 图像高度 colorDark:\"#000000\", // 前景色 colorLight:\"#ffffff\", // 背景色 correctLevel: QRCode.CorrectLevel.H // 容错等级 &#125;); qrCode.clear(); qrCode.makeCode(URL); &#125;,100) &#125; &lt;/script&gt; &lt;style lang=\"less\" scoped&gt; #qrcode &#123; display: inline-block; margin-top: 6rem; img &#123; width: 60%; height: 60%; background-color: #fff; //设置白色背景色 padding: 6px; // 利用padding的特性，挤出白边 &#125;&#125; &lt;/style&gt;","path":"2019/12/30/QRCode/","date":"12-30","excerpt":"在Vue项目中，前端生成站点二维码，使用APP扫码功能达到扫码加油的目的。","tags":[{"name":"QRCode","slug":"QRCode","permalink":"issummer.cn/tags/QRCode/"}]},{"title":"Vue路由传参","text":"Vue路由传参的方式:this.$router.push({path：’’,query:{}})和this.$route.push({name:’’},params:{}); 一、方法一：this.$router.push(path:’’,query:{})传参方式： 123456this.$router.push(&#123; path:&apos;/xxx&apos;, query:&#123; id:id &#125;&#125;) 接受参数的方式： 12const res = this.$route.query;this.id = res.id; 二、方法二、this.$router.push({name:’”,params:{}})传参方式： 123456this.$router.push(&#123; name:&apos;&apos;, params:&#123; id:id &#125;&#125;) 接受参数的方式： 12const res = this.$route.params;this.id = res.id 注意：params传参：push里面只能是name:’’,不是path:’/‘，这是因为params只能使用name来引入路由，如果写成path：’/‘，接受参数页面将会是undefined；二者区别： 直白的来说query相当于get请求，页面跳转，我们在地址栏可以看到请求参数，params相当于post请求，参数不会在地址栏显示出来。 还有就是传参是this.$router.push(),而接收参数是this.$route.params,前者是$router,后者是$route. this.$router和this.$route的区别： 1、$router为VueRouter实例，当我们想要进入不同的URL，可以使用$router.push()方法 2、$route为当前router跳转对象，里面可以获取name、path、query、params","path":"2019/11/02/vue-router-param/","date":"11-02","excerpt":"Vue路由传参的方式:this.$router.push({path：’’,query:{}})和this.$route.push({name:’’},params:{});","tags":[]},{"title":"mongodb-redis","text":"mongodb和redis的安装 一、mongodb的安装1、安装brew /usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;2、进入文件目录：cd /usr/local3、下载指定版本的mongodb4、环境的配置 vi ~/.bash_profile #user root export PATH=${PATH}:/usr/local/mysql/bin export NODE_PATH=/usr/local/lib/node_modules 在编辑之后，可以把mongodb的路径贴在后面； export PATH=${PATH}:/usr/local/mysql/bin:/usr/local/mongodb/bin 退出编辑的方式为，esc -&gt; :wq -&gt; enter5、配置mongo.conf logpath=/usr/local/var/log/mongodb/mongo.log logappend=true dbpath=/usr/local/var/mongodb fork=true port=27017 如果本机无法连接远程机器，在末尾添加bind_ip = 0.0.0.0,最后再启动mongo6、启动方式 mongod -f /usr/local/etc/mongod.conf 二、redis的安装1、在已经安装好了brew的情况下,安装Redis brew install redis2、启动redis redis-server","path":"2019/10/24/mongodb-redis/","date":"10-24","excerpt":"mongodb和redis的安装","tags":[{"name":"mongodb、redis","slug":"mongodb、redis","permalink":"issummer.cn/tags/mongodb、redis/"}]},{"title":"node版本管理--升级和降级","text":"Node版本的升级和降级 在开发的工程中，我们可能需要经常切换node版本来应对不同的开发环境，所以需要经常使用不同版本的node 一、安装npm插件n ,通过n模块来管理node版本1、全局安装n模块 1npm instlal -g n 2、安装当前稳定版本 1n stable或者sudo n stable 3、安装最新版本的 1n latest或者sudo n latest 4、安装指定版本的node 1n v8.16.0 5、卸载指定的node版本 1n rm v8.16.0 二、使用nvm管理node版本1、安装nvm 1brew install nvm 2、使用nvm安装node版本 1234// 安装最新版本nvm isntall node// 安装指定版本nvm install 8.16.0 3、查看所有版本 1nvm ls 4、切换node版本 1234// 使用最新版本nvm use node // 使用指定版本nvm use 8.16.0 通常我会使用第二种方式 例如：我在一个项目中使用的是node@6.13.2,新项目使用的是node@8.16.0, 先要安装node@8.16.0，nvm install 8.16.0， 然后，nvm use 8.16.05、卸载指定版本的node 1nvm uninstall v6.13.2 6、设置系统默认的node版本 1nvm alias default v8.16.0 这样使用的node的默认版本为8.16.0","path":"2019/10/23/node/","date":"10-23","excerpt":"Node版本的升级和降级","tags":[{"name":"node","slug":"node","permalink":"issummer.cn/tags/node/"}]},{"title":"常用的git提交代码命令","text":"日常开发使用的git提交代码的方法 一、初始化本地仓库，提交代码，提交到远程git仓库1、初始化代码仓库 git init2、将当前目录下的所有文件放到暂存区 git add .3、查看文件状态 git status4、添加提交的描述信息 git commit -m “提交的描述信息”5、远程仓库地址 git remote add origin “远程仓库地址”6、推送到远程仓库 git push -u origin master 二、创建分支，提交代码到分支1、创建切换分支 git checkout -b dev dev为分支名称 git add . git commit -m ‘描述’ git push –set-upstream origin dev1 将分支推送到远程仓库 切换到主分支 git checkout master git merge dev 将dev合并到主分支 git push origin master 推送到远程仓库 三、克隆指定分支12git clone -b master git@gitee.com:username/projectname.gitgit clone -b admin git@gitee.com:username/projectname.git","path":"2019/10/23/git/","date":"10-23","excerpt":"日常开发使用的git提交代码的方法","tags":[{"name":"git","slug":"git","permalink":"issummer.cn/tags/git/"}]},{"title":"v-for指令","text":"v-for是比较常用的Vue指令,常用来渲染数据列表。 1、v-for指令需要使用item in List形式的语法，其中List是源数据数组，item是被迭代的数组元素的别名。 123&lt;ul id=\"app\"&gt; &lt;li v-for=\"item in List\"&gt;&#123;&#123;item.message&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 123456789var example = new Vue(&#123; el: '#app', data:&#123; List:[ &#123;message:'Jack'&#125;, &#123;message:'Rose'&#125; ] &#125;&#125;) 结果为： Jack Rose 2、在v-for块中，我们可以访问所有的父作用域的属性，v-for还支持可选的第二个参数，即当前项的索引 12345&lt;ul id=\"app\"&gt; &lt;li v-for=\"（item,index) in List\"&gt; &#123;&#123;parenMessage&#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123;item.message&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678910var example = new Vue(&#123; el: '#app', data:&#123; parentMessage:'parent', List:[ &#123;message:'Jack'&#125;, &#123;message:'Rose'&#125; ] &#125;&#125;) 结果为： parent-0-Jack parent-1-Rose 我们可以使用of 替代 in 作为分隔符，因为它更接近JavaScript迭代器的语法 待续。。。。","path":"2019/10/06/v-for/","date":"10-06","excerpt":"v-for是比较常用的Vue指令,常用来渲染数据列表。","tags":[{"name":"vue","slug":"vue","permalink":"issummer.cn/tags/vue/"}]},{"title":"我的随笔--持续更新。。。","text":"如果累了，就停下来看看书，冷静一下。 随笔（一）、最难迈出的是第一步人生有很多第一次，比如，第一次背着书包去学校，第一次踏入这个复杂的社会，第一次一个人去一个陌生的城市，。。。 我们面对第一次时的心情往往是复杂的，我们会有一种喜悦感，同时还伴有一丝紧张焦虑和害怕。之所以会有一种喜悦感，是因为我们知道，每往前踏出一步，便意味着我们又成长了，对这个社会了解更深入了一层。 是啊，人生最难的事情便是迈出第一步了，如果你连第一步都不愿意往外迈，或者都不敢迈的话，那么成功只会深深地藏在你的心里，它永远不会实现。 “嗯嗯，希望你以后能闯出一片属于你自己的天地！我们一起加油！” (二)、2019年10月1日 国庆节时间：1949.10.1 – 2019.10.1今天是祖国70周年生日，祝伟大的祖国繁荣昌盛，国富民强，前人栽树后人乘凉，永远缅怀革命先烈的流血牺牲。 70年弹指一挥间，现在的祖国山河无恙国富民强，我们足以告慰先烈，这盛世如先辈所愿。 (三)、2019年10月6日曾经，你认为离你很远的30岁，其实，已经就在你的面前。 （四）、2019年11月8号最伤感的一句话： 目之所及，皆是回忆！ (五)、2020年4月30日过去 – 是经历，是回忆；现在 – 整理过去，计划未来；将来 – 一定要相信，将来是美好的，是值得憧憬的。 (六)、2020年5月21日你快乐过生活 我拼命去生存几多人位于山之巅俯瞰我的疲倦渴望被成全 努力做人谁怕气喘但那终点 挂在那天边你界定了生活 我侮辱了生存只适宜滞于山之谷整理我的凌乱渴望大团圆 脚下路程难以削短未见终点 也未见恩典 我与你极远愈望愈无望 未来没有我在断崖下 尽头吧 乐园未有过仿佛天一黑天一光挥发了一句再会只见人下堕快慰继续传播 你都不慰问我区分到太清楚 太严苛你快乐过生活 我拼命去生存几多人位于山之巅俯瞰我的疲倦渴望被成全 努力做人谁怕气喘但那终点 挂在那天边你界定了生活 我侮辱了生存只适宜滞于山之谷整理我的凌乱渴望大团圆 脚下路程难以削短未见终点 也未见恩典 我与你极远我却尚要生存偷偷存活于山之谷等到某天魂断你继续盘旋 我 继续埋藏我爱恋没有终点 永没有终点那永远极远","path":"2019/09/30/book/","date":"09-30","excerpt":"如果累了，就停下来看看书，冷静一下。","tags":[{"name":"book","slug":"book","permalink":"issummer.cn/tags/book/"}]},{"title":"使用Vue-cli3.0搭建项目","text":"使用Vue-cli3.0搭建项目的流程： 一、安装依赖工具：Node查看node版本： 12node -vnpm -v Node自带npm模块，可以直接使用命令行安装npx,当我们使用不同版本的node时，我们可以直接通过npx命令切换node版本 12345// 安装npxnpm install -g npx// 切换node版本npx node@8.12.0 -v //使用node 8.12.0版本npx node@8.16.0 -v //使用node 8.16.0版本 二、全局安装vue-cli1234// 全局安装vue-cli3.0npm install -g @vue/cli// 或者使用yarnyarn global add @vue/cli 三、创建一个项目使用vue create 12// 创建一个项目vue create project-name 如果是vue-cli2.x 旧版本，创建一个项目 12npm install -g @vue/cli-initnpm init webpack my-project","path":"2019/09/30/vue-project/","date":"09-30","excerpt":"使用Vue-cli3.0搭建项目的流程：","tags":[{"name":"Vue、Vue-cli","slug":"Vue、Vue-cli","permalink":"issummer.cn/tags/Vue、Vue-cli/"}]},{"title":"如何使用CSS画三角形","text":"如何使用CSS画三角形？ 三角形的画法一般经常使用三角形作为提示框、下拉菜单等功能。1、HTML结构 12345678&lt;div class=\"item0\"&gt;&lt;/div&gt;&lt;div class=\"item1\"&gt;&lt;/div&gt;&lt;div class=\"item2\"&gt;&lt;/div&gt;&lt;div class=\"item3\"&gt;&lt;/div&gt; 2、将类名为item的块级元素的width、height设置为0 1234.item0&#123; width:0; height:0;&#125; 3、将类名为item的元素的3个border的颜色设置为transparent，箭头指向的对面border设置颜色； 123456789 .item0&#123; width: 0px; height: 0px; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 50px solid transparent; border-bottom: 80px solid blue; background: white;&#125; 上面的为方向向上的三角形4、依次类推可以画出方向向左、右、下的三角形 123456789101112131415161718192021222324252627 .item1&#123; width: 0px; height: 0px; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 80px solid green; border-bottom: 50px solid transparent; background: white;&#125;.item2&#123; width: 0px; height: 0px; border-left: 50px solid transparent; border-right: 80px solid violet; border-top: 50px solid transparent; border-bottom: 50px solid transparent; background: white;&#125;.item3&#123; width: 0px; height: 0px; border-left: 80px solid purple; border-right: 50px solid transparent; border-top: 50px solid transparent; border-bottom: 50px solid transparent; background: white;&#125;","path":"2019/08/10/trangel/","date":"08-10","excerpt":"如何使用CSS画三角形？","tags":[{"name":"transparent、border","slug":"transparent、border","permalink":"issummer.cn/tags/transparent、border/"}]},{"title":"用纯 JS 实现点击一个列表时，输出对应的索引号?","text":"面试题目：用纯 JS 实现点击一个列表时，输出对应的索引号?(不能使用 jQuery) 如何使用原生 Javascript 实现点击一个列表时，输出对应的索引号？看到这个题目，我就知道了，面试官可能会考察一下对闭包的掌握。经验不足的小伙伴们可能会这样去实现： 123456789101112131415161718&lt;div&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var dom = document.querySelectorAll('ul li'); for(var i=0,len=dom.length;i&lt;len;i++)&#123; dom[i].addEventListener('click',function()&#123; console.log(i); &#125;,false) &#125;&lt;/script&gt; 当我们点击列表的时候，弹出的都是 6，这是怎么回事呢？这是因为我们在使用了 var 声明的变量，是全局作用域，不是块级作用域。也就是说，for 循环 6 次，每次改变的都是同一个 i，所以它的值会从 0 一直加到 6。还有一个问题就是闭包导致的，闭包保存的是外部变量的引用，而不是值。因此可以循环 6 次监听器创建 6 个闭包，它里面的 i 引用的是同一个，全部指向了 6。 方法一：使用ES6中的 let替代var12345678&lt;script&gt; var dom = document.querySelectorAll('ul li'); for(let i=0,len=dom.length;i&lt;len;i++)&#123; dom[i].addEventListener('click',function()&#123; console.log(i); &#125;,false) &#125;&lt;/script&gt; let声明的变量支持的是块级作用域。 方法二：使用立即执行函数来判断闭包对外部变量i的引用12345678910&lt;script&gt; var dom = document.querySelectorAll('ul li'); for(var i=1,len = dom.length;i&lt;len;i++)&#123; (function(i)&#123; dom[i].addEventListener('click',function()&#123; console.log(i); &#125;,false) &#125;)(i) &#125;&lt;/script&gt; 方法三：事件委托的方法12345678var ul = document.querySelector('ul');var dom = document.querySelectorAll(\"ul li\");ul.addEventListener('click',function(e)&#123; var target = e.target; if(target.nodeName.toLowerCase() === 'li')&#123; console.log([].indexOf.call(dom,target)); &#125;&#125;,false); 这个方法使用了事件监听，减少了监听器的绑定。","path":"2019/08/09/fe/","date":"08-09","excerpt":"面试题目：用纯 JS 实现点击一个列表时，输出对应的索引号?(不能使用 jQuery)","tags":[{"name":"纯JS、事件监听/委托、立即执行函数","slug":"纯JS、事件监听-委托、立即执行函数","permalink":"issummer.cn/tags/纯JS、事件监听-委托、立即执行函数/"}]},{"title":"输入url到页面的加载完成发生了什么？","text":"从浏览器中输入URL到页面的加载发生了什么？ 一、过程 1、DNS解析： 2、TCP的三次握手 3、发送HTTP请求 4、服务器处理请求并返回报文 5、浏览器解析渲染页面 6、连接结束","path":"2019/08/01/url/","date":"08-01","excerpt":"从浏览器中输入URL到页面的加载发生了什么？","tags":[{"name":"url、tcp、http","slug":"url、tcp、http","permalink":"issummer.cn/tags/url、tcp、http/"}]},{"title":"防抖（debounce）和节流（throttle）","text":"防抖（debounce）：任务频繁触发情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。 节流（throttle）：指定时间间隔内只会执行一次任务。&emsp;防抖与节流的原理：使用setTimeout来存放将要执行的函数。其中函数节流就是利用标记符来控制本次执行完毕。函数防抖就是利用clearTimeout来清楚执行的函数。目的为了节约计算机资源，从而达到一个更好的运行效果。 一、防抖&emsp;用户在输入框内容校验等操作时，如果事件处理函数的调用频率无限制，会加重浏览器的负担，导致用户体验会很不好，防抖和节流的方式减少调用频率，同时又不影响实际效果。 下面是一个防抖的小案例： 123456789101112131415161718192021222324252627&lt;button id=\"debounce\"&gt;点我防抖&lt;/button&gt; &lt;script&gt; window.onload = function () &#123; //获取按钮并绑定事件 var myDebounce = document.getElementById(\"debounce\"); myDebounce.addEventListener(\"click\",debounce(sayDebounce)); &#125;; //防抖功能函数，接受传参 function debounce(fn)&#123; //创建一个标记用来存放定时器的返回值 let timeout = null; return function()&#123; //每次当用户点击、输入的时候，把前一个定时器消除 clearTimeout(timeout); //创建一个新的setTimeout，这样能保证点击按钮后的间隔内， //如果用户还点击的话，就不会执行fn函数 timeout = setTimeout(() =&gt; &#123; fn.call(this,arguments); &#125;,1000); &#125;; &#125;; //防抖事件的处理 function sayDebounce()&#123; // ...有些需要防抖的工作，在这里进行 console.log(\"防抖成功~\"); &#125; &lt;/script&gt; 在触发点击事件后，如果用户再次点击了，我们会清空之前的定时器，重新生成一个定时器。意思就是：这件事儿需要等待，如果你反复催促，就重新计时。&emsp;总结一下就是：第一次触发事件，一段时间内没有再次触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，再一次触发了事件，就会重新开始延时。 二、节流&emsp;节流：指定时间间隔内只会执行一次任务。节流的应用： 1、懒加载监听滚动条的位置，使用节流按照一定的频率进行获取。 2、点击提交按钮，只允许一定时间内点击一次。 1234567891011121314151617181920212223242526272829303132&lt;button id=\"throttle\"&gt;点我防抖&lt;/button&gt;&lt;script&gt; window.onload = function () &#123; //获取按钮并绑定事件 var myThrottle = document.getElementById(\"throttle\"); myThrottle.addEventListener(\"click\",throttle(sayThrottle)); &#125;; //节流函数 function throttle(fn)&#123; //通过闭包保存一个标记 let canRun = true; return function()&#123; //在函数开头判断标志是否为true，不为true则中断函数 if(!canRun)&#123; return; &#125; //将canRun设置为false，防止执行之前再被执行 canRun = false; //定时器 setTimeout(() =&gt; &#123; fn.call(this,arguments); //执行完事件(例如调用完接口)之后，重新将这个标志设置为true canRun = true; &#125;,1000); &#125;; &#125;; //需要节流的事件 function sayThrottle()&#123; // ...有些需要防抖的工作，在这里进行 console.log(\"节流成功~\"); &#125;&lt;/script&gt;","path":"2019/07/09/debounce-throttling/","date":"07-09","excerpt":"防抖（debounce）：任务频繁触发情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。","tags":[{"name":"debounce、throttle","slug":"debounce、throttle","permalink":"issummer.cn/tags/debounce、throttle/"}]},{"title":"常用的Linux命令","text":"在开发过程中，一些常用的Linux命令： 常用的Linux命令1、vim test.html 创建新的文件 &emsp; vim + 文件名.后缀2、ls 查看当前文件夹下的文件&emsp; ls -a 列出所有文件，包括隐藏文件&emsp; ls -1 每行列出一个文件，以单列形式列出3、cat test.html 将该文件内容打印显示出来&emsp; cat test1.html&emsp; cat test2.html&emsp; cat test1.html test2.html&gt;test3.html&emsp; cat test3.html 将多个文件合并到目标文件中。 &emsp; cat test1.html&emsp; cat test2.html&emsp; cat test1.html test2.html&gt;&gt;test4.html 将几个文件附加到目录文件中4、mv 移动或重命名文件和目录&emsp; mv file1.txt file2.txt 将file1文件命名为file2&emsp; 用法：&emsp; cat 1.txt&emsp; mv 1.txt 2.txt&emsp; mv file1.txt file2 将file1文本移动到file2目录5、touch file 命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的空白文件。&emsp; touch newfile6、mkdir file 创建文件夹7、cd ../ 返回当前文件夹的上一层&emsp; cd / 返回到根目录下8、rm -rf folder 删除文件夹","path":"2019/07/09/command/","date":"07-09","excerpt":"在开发过程中，一些常用的Linux命令：","tags":[{"name":"Linux","slug":"Linux","permalink":"issummer.cn/tags/Linux/"}]},{"title":"如何理解原型链中的prototype和__proto__？","text":"JavaScript是动态的，本身不提供一个class实现。在ES2015/ES6中引入了class关键字，但那只是语法糖，JavaScript仍然是基于原型的。 一、什么是原型链？&emsp;&emsp;谈到继承时，JavaScript只有一种结构：对象。 MDN文档上是这样说的：每个实例对象（object）都有一个私有属性（称之为__proto__）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象（__proto__）,层层向上直到一个对象的原型对象为null。根据定义，null没有原型，并作为这个原型链中的最后一个环节。 二、换种方式理解原型链？&emsp;&emsp;之前在慕课网上，听过一个讲师举了一个很有趣的例子来介绍什么是prototype（当时偷偷的用手机截了图^o^）:&emsp;&emsp;简单粗暴一点，我们把prototype理解成一个“备胎”,手艺还是祖传的。有一个姑娘不会修电脑，自己也不想学，就去找prototype说你学学吧，学好了帮我把修电脑这活儿做好,prototype学会了修电脑之后,这个姑娘电脑有问题就会去找prototype,其他的姑娘再想修电脑时候，prototype这修电脑的技术也能直接拿出来用。后来，又有姑娘请prototype帮忙诊个脉,prototype没有地方学,就往祖上一辈辈的问去，后来了解到他爷爷会诊脉，后来再有人找他诊脉，prototype就把病人带着找它爷爷。再后来，又有一个姑娘让prototype给她造个机器人，prototype问遍了祖上，没人会这门技术，只能告诉这姑娘null了。 三、为什么需要原型和原型链？&emsp;&emsp;看一个小例子： 12345678910function Person(name,age)&#123; this.name = name; this.age = age; this.eat = function()&#123; console.log(age + \"岁的\" + name + \"在吃饭\"); &#125;&#125;let p1 = new Person(\"YQ\",27);let p2 = new Person(\"YQ\",27);console.log(p1.eat === p2.eat); //false &emsp;&emsp;我们发现上面的例子,对于同一个函数,我们可以通过new生成出来的实例,p1和p2的eat是不同的。我们想个办法，建立一个类似于共享库的对象，这样就可以在需要的时候，调用一个类似共享库的对象，让实例能够沿着某个“线索”去找到自己的归处。这个“线索”就是我们的原型链 prototype。 1234567891011function Person(name)&#123; this.name = name;&#125;//通过构造函数的Person的prototype属性找到Person的原型对象Person.prototype.eat = function()&#123; console.log(\"吃饭\")；&#125;let p1 = new Person(\"YQ\",27);let p2 = new Person(\"于齐\",27)console.log(p1.eat === p2.eat);//true &emsp;通过分享的形式，这两个实例对象指向相同的位置了，也就是我们想要创建的共享库的对象。 四、prototype是什么玩意儿呢？知乎上有一篇文章（https://zhuanlan.zhihu.com/p/22989691） 写的很好，总结一下就是：1、JavaScript本源是空的，即：null,这个就是JavaScript的“始祖”； 2、null通过__proto__产生了NO1,即：NO1.__proto__ == null; 3、NO1根据自己的原型prototype创建了对象Object，即：Object.prototype == NO1; 4、NO1.__proto__ == null,我们把prototype叫做原型，好比Object的原型是神，同时proto叫做原型链，有了这个proto，Object、NO1、JS之间才有联系，此时，Object.prototype.__proto__ == null， 5、有几条公式： 123Object.__proto__ === Function.prototype;Function.prototype.__proto__ === Object.prototype;Object.prototype.__proto__ === null;","path":"2019/07/07/prototype/","date":"07-07","excerpt":"JavaScript是动态的，本身不提供一个class实现。在ES2015/ES6中引入了class关键字，但那只是语法糖，JavaScript仍然是基于原型的。","tags":[{"name":"原型链、prototype、__proto__","slug":"原型链、prototype、-proto","permalink":"issummer.cn/tags/原型链、prototype、-proto/"}]},{"title":"Class语法","text":"一、Class语法： Class在语法上更加贴合面向对象的写法；Class实现继承更易读、易理解；本质是语法糖，使用了prototype。 1234567891011121314$ class Mathhandle&#123; constructor(x,y)&#123; this.x = x; this.y = y; &#125; add()&#123; return this.x + this.y &#125;&#125; const mm = new Mathhandle(1,2); console.log(mm.add()); typeof Mathhandle //function console.log(Mathhandle === Mathhandle.prototype.constructor); // true 二、Class继承 123456789101112131415161718192021class Animal&#123; constructor(name)&#123; this.name = name; &#125; eat()&#123; console.log(this.name + 'eat') &#125;&#125;class Dog extend Animal&#123; constructor(name)&#123; super(name) this.name = name; &#125; say()&#123; console.log(`$&#123;this.name&#125; eat`) &#125; const dog = new Dog('hashiqi'); dog.say(); dog.eat();&#125;","path":"2019/07/03/ES6/","date":"07-03","excerpt":"一、Class语法： Class在语法上更加贴合面向对象的写法；Class实现继承更易读、易理解；本质是语法糖，使用了prototype。","tags":[{"name":"ES6、JavaScript、Class","slug":"ES6、JavaScript、Class","permalink":"issummer.cn/tags/ES6、JavaScript、Class/"}]},{"title":"Promise","text":"Promise是异步编程的一种解决方案，简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 语法上讲，Promise是一个对象，从它可以获取异步操作的消息。Promise的两个特点： （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 （2）一旦状态改变，就不会改变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。一、Promise基本用法： 1、Promise实例： Promise构造函数接受一个函数作为参数，该函数的两个函数分别是resolve和reject 12345678$ const promise = new Promise(function(resolve,reject)&#123; // ... some code if(/*异步操作成功*/)&#123; resolve(value); &#125;else&#123; reject(error); &#125; &#125;); Promise实例生成后，可以用 then方法分别指定resolved状态和rejected状态的回调函数。 12345$ promise.then(function(value)&#123; //success &#125;,function(error)&#123; //failure &#125;); 二、使用Promise分别获取图片的宽高 new Promise实例，而且要return，new Promise时要传入函数，函数有resolve reject两个参数，成功时执行resolve（）、失败时执行reject（）、then监听结果 123456789101112131415161718192021222324252627$ function loadImg()&#123; const promise = new Promise(function(resolve,reject)&#123; var img = document.createElement('img') img.onload = function()&#123; resolve(img) &#125; img.onerror()&#123; reject() &#125; img.src = src &#125;) return promise&#125;var src = 'https://www.imooc.com/static/img/index/logo.png'var result = loadImg(src)//获取图片的宽度result.then(function(img)&#123; console.log(img.width)&#125;,function()&#123; console.log('failed')&#125;)//获取图片的高度result.then(function(img)&#123; console.log(img.height)&#125;,function()&#123; console.log('failed')&#125;)","path":"2019/06/19/promise/","date":"06-19","excerpt":"Promise是异步编程的一种解决方案，简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。","tags":[{"name":"Javascript、Promise","slug":"Javascript、Promise","permalink":"issummer.cn/tags/Javascript、Promise/"}]},{"title":"Hexo + Github Pages + Gal主题 + 阿里云域名搭建个人博客","text":"Hexo 常用命令 一、Create a new post –创建新文章1$ hexo new \"My New Post\" 二、Create a new page –创建新页面1$ hexo new page \"pageName\" 三、Run server –启动服务器1$ hexo server 简写：hexo s 四、Generate static files –生成静态文件1$ hexo generate --生成静态文件 简写： hexo g 五、Deploy to remote sites –部署到远程站点1$ hexo deploy --部署文章 简写：hexo d 六、hexo常用命令12345$ hexo new page \"pageName\" #新建页面$ hexo new \"postName\" #新建页面$ hexo generate #生成静态页面至public目录 简写：hexo g$ hexo server #开始预览访问端口（默认端口4000，Ctrl + C终止server） 简写：hexo s$ hexo deploy #部署到GitHub 简写：hexo d 七、Github根目录下创建CNAME文件（无后缀）在CNAME文件里面填写我的域名（加不加www看自己的喜好），下面是我的Github根目录下创建的CANAME文件。阿里云域名解析过程不详细赘述…… 1$ issummer.cn","path":"2019/06/19/hello-world/","date":"06-19","excerpt":"Hexo 常用命令","tags":[{"name":"hexo","slug":"hexo","permalink":"issummer.cn/tags/hexo/"}]}],"categories":[],"tags":[{"name":"H5、barcode","slug":"H5、barcode","permalink":"issummer.cn/tags/H5、barcode/"},{"name":"QRCode","slug":"QRCode","permalink":"issummer.cn/tags/QRCode/"},{"name":"mongodb、redis","slug":"mongodb、redis","permalink":"issummer.cn/tags/mongodb、redis/"},{"name":"node","slug":"node","permalink":"issummer.cn/tags/node/"},{"name":"git","slug":"git","permalink":"issummer.cn/tags/git/"},{"name":"vue","slug":"vue","permalink":"issummer.cn/tags/vue/"},{"name":"book","slug":"book","permalink":"issummer.cn/tags/book/"},{"name":"Vue、Vue-cli","slug":"Vue、Vue-cli","permalink":"issummer.cn/tags/Vue、Vue-cli/"},{"name":"transparent、border","slug":"transparent、border","permalink":"issummer.cn/tags/transparent、border/"},{"name":"纯JS、事件监听/委托、立即执行函数","slug":"纯JS、事件监听-委托、立即执行函数","permalink":"issummer.cn/tags/纯JS、事件监听-委托、立即执行函数/"},{"name":"url、tcp、http","slug":"url、tcp、http","permalink":"issummer.cn/tags/url、tcp、http/"},{"name":"debounce、throttle","slug":"debounce、throttle","permalink":"issummer.cn/tags/debounce、throttle/"},{"name":"Linux","slug":"Linux","permalink":"issummer.cn/tags/Linux/"},{"name":"原型链、prototype、__proto__","slug":"原型链、prototype、-proto","permalink":"issummer.cn/tags/原型链、prototype、-proto/"},{"name":"ES6、JavaScript、Class","slug":"ES6、JavaScript、Class","permalink":"issummer.cn/tags/ES6、JavaScript、Class/"},{"name":"Javascript、Promise","slug":"Javascript、Promise","permalink":"issummer.cn/tags/Javascript、Promise/"},{"name":"hexo","slug":"hexo","permalink":"issummer.cn/tags/hexo/"}]}